Dim hwnd
Dim round
Dim toward
Dim n
Dim checkTimes
Dim debug
// 小地图角色的颜色
Dim roleColor
// 小地图的左上和右下点
Dim static_x1, static_x2, static_x3, static_x4
// 我的坐标&敌人的坐标
Dim positionX1, positionX2, positionY1, positionY2
Call init

Sub init
	static_x1 = 794
	static_y1 = 23
	static_x2 = 1000
	static_y2 = 122
	debug = true
	// 角色小地图颜色
	// roleColor = "00ccff"
	roleColor = "0033cc"
	// 计数器初始化
	checkTimes = 0
	// 初始化已打副本次数
	n = 0
	hwnd = Plugin.Window.MousePoint
	If (Plugin.Window.GetClass(hwnd) <> "MacromediaFlashPlayerActiveX") Then 
		MessageBox "未检测到窗口，启动时鼠标需要放在游戏内！"
	Else 
		Call 大漠注册
		Call bund(hwnd)
		// 将主句柄保存
		Call saveMaster(hwnd)
		// 激活窗口
		dm.moveTo 0, 0
		dm.leftClick 
		Call main
	End If
End Sub

Sub main
	While True
		checkTimes = checkTimes + 1
		If checkTimes > 100 Then 
			checkTimes = 0
		End If
		// 检测hwnd是否失效
		Call hwndCheck(hwnd)
		If isEnterLevel() Then
			// 已进入副本，优先判断屏距
			If isMyRound() Then
				Call 打副本策略
			End If
		Else 
			// 检测是否需要选地图
			Call needPrepare
			Call needCloseMap
			Call needCloseTip
			Call needCloseEmail
			// 检测是否需要将奖励放进背包
			If checkTimes Mod 5 = 0 Then 
				Call needCreateRoom
				Call needDraw
			End If
		End If
		Delay 700 * (1 - (Form1.Slider1.Value / 1000))
	Wend
End Sub


Sub needCreateRoom
	dm.FindPic 689, 450, 750, 520, "C:\tmp\蛋4.5-大厅标识.bmp", 101010, 0.8, 0, intX, intY
	If intX > 0 And intY > 0 Then 
	 	TracePrint "检测到在大厅内"
		dm.moveTo intX + 10, intY + 10
		dm.leftClick 
		Delay 500
		dm.moveTo 415, 442
		dm.leftClick
	End If
End Sub

Sub 打副本策略
	round = round + 1
	Form1.Label4.Caption = "第" & (n + 1) & "次副本，第" & round & "回合"
	TracePrint "第" & round & "回合"
	If round = 1 and Form1.CheckBox2.Value = 0 Then 
		// 计算屏距
		TracePrint "计算屏距"
		Call calcUnitDistance()
	End If
	While isMyRound()
		Call attackAuto
	Wend
End Sub

Sub 要打的副本
	Dim x, y
	// x, y 待选择副本的位置
	round = 0
	toward = 0
	Form1.Label4.Caption = "第" & (n + 1) & "次副本，开始！"
	
	dm.moveTo 216 + 556 * (Form1.Slider3.Value / 10), 300
	dm.leftClick 
	Delay 800
	
	Select Case Form1.ComboBox1.ListIndex Mod 2
		// 选择行
		Case 0
			y = 360
		Case 1
			y = 420
	End Select
	// 需要向下翻页
	If Form1.ComboBox1.ListIndex > 1 Then 
		Dim clickCount
		clickCount = 0
		For Fix(Form1.ComboBox1.ListIndex / 2)
			dm.moveTo 767, 426
			For 6
				dm.leftClick 
				Delay 100
				clickCount = clickCount + 1
				If clickCount = 9 Then 
					// 该端的规则是每点9下就需要点一次下来保证8个图显示在一个框内
					dm.moveTo 767, 427
					dm.leftClick 
				End If
			Next
		Next
	End If
	
	Select Case Form1.ComboBox2.ListIndex Mod 4
		Case 0
			x = 280
		Case 1
			x = 420
		Case 2
			x = 560
		Case 3
			x = 700
	End Select
	dm.moveTo x, y
	dm.leftClick 
	// 难度，根据输入框输入调整
	dm.moveTo 214 + 567 * (Form1.Slider2.Value / 10), 500
	dm.leftClick
	dm.moveTo 500, 563
	dm.leftClick 
	Delay 300
End Sub

/**
 * 自动寻找屏距，并计算攻击
 **/
Sub attackAuto
	If Form1.CheckBox1.Value Then 
		// 指定角度力度攻击
		Call attackWithAngle(Form1.InputBox4.Text, Form1.InputBox5.Text, Form1.InputBox7.Text)
	Else 
		// 寻找自身位置
		If getMyPosition() and getEnemyPosition() Then 
			TracePrint "我的坐标:" & positionX1 & ", " & positionY1
			TracePrint "敌人的坐标:" & positionX2 & ", " & positionY2
			Call adjustDirection()
			
			// 自动攻击
			Call calcAndAttack()
		Else 
			// 未找到自身位置
			Delay 1
		End If
	End If
End Sub

// 尝试计算屏距
Function calcUnitDistance()
	// 自动寻找屏距，循环10次
	Dim count, flag, arr(10)
	For i = 0 To 10
		arr(i) = -1
		flag = true
		For 5
			If dm.findStr(static_x1, static_y1, static_x2, static_y2, "屏", "999999-000000", 1, x3, y3) = 0 Then 
				If flag Then 
					count =1
				End If
				While flag
					If dm.findColor(x3, y3, static_x2, y3 + 1, "999999-000000", 1, 0, x4, y4) Then 
						count = count + 1
						x3 = x3 + 1
					Else
						flag = false
					End If
					If x3 >= static_x2 Then 
						flag = false
					End If
				Wend
				Exit For
			End If
		Next
		If debug Then 
			TracePrint "第" & i & "次测量屏距：" & count & "px"
		End If
		arr(i) = count
	Next
	
	// 先排序
	For i = 0 To UBound(arr) - 1
		For j = i + 1 To UBound(arr)
			If arr(i) > arr(j) Then 
				Dim tmp
				tmp = arr(i)
				arr(i) = arr(j)
				arr(j) = tmp
			End If
		Next
	Next
	
	Dim maxTimes, times, nowDistance, maxDistance
	For i = 0 To UBound(arr)
		If arr(i) <> nowDistance Then 
			times = 1
			nowDistance = arr(i)
		Else 
			times = times + 1
		End If
		If times > maxTimes Then 
			maxTimes = times
			maxDistance = nowDistance
		End If
	Next
	
	// 投票选择出最佳屏距
	If debug Then 
		TracePrint "1屏的距离为" & maxDistance & "px" & "出现次数" & times
	End If
	// count / 10为1距，更新距离
	Form1.InputBox3.Text = maxDistance / 10
	dm_ret = dm.UseDict(0)
End Function

// 调整方向
Sub adjustDirection
	toward = -1
	While isMyRound() and toward = - 1 
		toward = getToward()
		If toward = 1 and positionX2 - positionX1 < 0 Then 
			// 朝向右，但敌人在左
			dm.keyPressChar "a"
			TracePrint "调整方向(左)"
		End If
		If toward = 0 and positionX2 - positionX1 > 0 Then 
			// 朝向左，但敌人在右
			dm.keyPressChar "d"
			TracePrint "调整方向(右)"
		End If
	Wend
End Sub

// 计算角度力度并攻击 x1, y1 : 我的坐标，y1, y2: 敌人的坐标
Sub calcAndAttack
	Dim strength, angle
	If Form1.CheckBox1.Value Then 
		// 手动攻击
		angle = Form1.InputBox4.Text
		strength = Form1.InputBox5.Text
	End If
	angle = getBestAngle()
	strength = getStrength(angle, Abs((positionX2 - positionX1) / Form1.InputBox3.Text), ((positionY1 - positionY2) / Form1.InputBox3.Text))
	
	
	TracePrint "角度" & angle & "力度:" & strength
	Call attackWithAngle(angle, strength, Form1.InputBox7.Text)
End Sub

// 寻找我的坐标
Function getMyPosition()
	If dm.findStr(static_x1, static_y1, static_x2, static_y2, "我", roleColor + "-000000", 0.8, intX, intY) = 0 Then 
		positionX1 = intX
		positionY1 = intY
		// 大漠找字默认找的是最上方坐标
		positionY1 = positionY1 + 10
		getMyPosition = True
	Else 
		getMyPosition = False
	End If
End Function

// 寻找敌人的坐标
Function getEnemyPosition()
	If dm.findColor(static_x1, static_y1, static_x2, static_y2, "ff0000-000000", 1, Form1.ComboBox3.ListIndex, intX, intY) Then 
		positionX2 = intX
		positionY2 = intY
		getEnemyPosition = True
	ElseIf dm.findColor(static_x1, static_y1, static_x2, static_y2, "99cc00-000000", 1, Form1.ComboBox3.ListIndex, intX, intY) Then
		// 找绿色（小鸡本（淦））
		positionX2 = intX
		positionY2 = intY
		
		getEnemyPosition = True
		TracePrint intX & ", " & intY
	Else 	
		TracePrint "未找到敌人"
		Delay 1
		getEnemyPosition = False
	End If
End Function

// 获取当前角度
Function getAngle()
	// BGR：1a1a1a 0d261a 241710 16201a 2b2228 0d0d26 201d1c 321d17 1d1d21 030d1c
	getAngle = dm.Ocr(23, 552, 77, 590, "000-000", 0.95)
	getAngle = Replace(getAngle, "我", "")
	getAngle = Replace(getAngle, "屏", "")
	getAngle = getAngle + 0
End Function

// 根据敌我的位置获取最佳角度
Function getBestAngle()
	Dim theta, vertical
	theta = - Atn((positionY2 - positionY1) / Abs(positionX2 - positionX1))  * 180 / (4 * Atn(1))
 	TracePrint "当前夹角：" & theta
	// 如果敌人在下面，那么直接20度或30度就可以
	If theta < -10 Then 
		getBestAngle = 30
		Exit Function
	ElseIf theta < 0 Then
		getBestAngle = 20
		Exit Function
	End If
	vertical = Abs(positionY2 - positionY1) / Form1.InputBox3.Text
	// 以夹角为界限，低于某个值的直接使用30度，其余情况的视垂直偏差情况使用50、65、70度
	If theta <= 20 Then 
		getBestAngle = 30
	ElseIf theta <= 26 Then
		getBestAngle = 40
	ElseIf theta <= 32 Then
		getBestAngle = 45
	ElseIf theta <= 50 Then
		getBestAngle = 50
	ElseIf theta <= 65 Then
		getBestAngle = 65
	Else 
		getBestAngle = 70
	End If
	// TODO 再检测垂直距离，如果垂直距离过高，则提高角度，ddtank中1屏高6距，超过半屏就该
End Function

// 根据角度、水平距离、垂直距离、1距的距离来就按力度，并对角度进行修正
// 水平距离：永远大于0，垂直距离：如果是正数表示Boss在自己的下面，否则Boss在上面
Function getStrength(angle, horizontal, vertical)
	// 30、40、45、50、65均已手测
	Dim strengthTable20, strengthTable30, strengthTable35, strengthTable40, strengthTable45, strengthTable50, strengthTable65, strengthTable70
	strengthTable20 = array(10, 19, 25, 30, 36, 40, 44, 48, 51, 54, 57, 60, 63, 66, 69, 72, 74, 76, 78, 80)
	strengthTable30 = array(14, 20, 24, 28, 32, 35, 38, 41, 44, 47, 50, 52, 55, 57, 60, 62, 65, 67, 69, 72)
	strengthTable35 = array(10, 16, 22, 26, 30, 33, 37, 40, 43, 45, 49, 51, 53, 55, 57, 59, 61, 63, 65, 67)
	strengthTable40 = array(12, 16, 20, 25, 30, 33, 35, 40, 43, 45, 48, 50, 53, 55, 58, 60, 62, 64, 67, 70)
	strengthTable45 = array(13, 16, 20, 25, 30, 33, 35, 38, 41, 45, 48, 51, 53, 55, 57, 59, 60, 63, 66, 68)
	strengthTable50 = array(14, 20, 24, 28, 32, 35, 38, 42, 44, 48, 50, 53, 55, 58, 60, 63, 65, 68, 70, 72)
	strengthTable65 = array(13, 20, 26, 31, 37, 41, 44, 48, 53, 56, 58, 61, 64, 67, 70, 73, 76, 79, 82, 85)
	strengthTable70 = array(18.5, 26.4, 32.6, 37.9, 42.7, 47.2, 51.3, 55.3, 59.1, 62.8, 66.3, 69.8, 73.1, 76.5, 79.7, 82.9, 86.1, 89.2, 92.3, 95.3)
	upOffset = Array(3, 2.425, 2, 1.55, 1.9, 1.15, 0.58, 0.24)
	Dim strength
	strength = 0
	If angle <= 20 Then 
		angle = 20
		strength = strengthTable20(Fix(horizontal + 0.000001) + 1)
	ElseIf angle <= 30 Then
		angle = 30
		strength = strengthTable30(Fix(horizontal + 0.000001) + 1)
	ElseIf angle <= 35 Then
		angle = 35
		strength = strengthTable35(Fix(horizontal + 0.000001) + 1)
	ElseIf angle <= 40 Then
		angle = 40
		strength = strengthTable40(Fix(horizontal + 0.000001) + 1)
	ElseIf angle <= 45 Then
		angle = 45
		strength = strengthTable45(Fix(horizontal + 0.000001) + 1)
	ElseIf angle <= 50 Then
		angle = 50
		strength = strengthTable50(Fix(horizontal + 0.000001) + 1)
	ElseIf angle <= 65 Then
		angle = 65
		strength = strengthTable65(Fix(horizontal + 0.000001) + 1)
	Else
		angle = 70
		strength = strengthTable70(Fix(horizontal + 0.000001) + 1)
	End If
	
	strength = strength + 0
	
	If vertical > 0 Then 
		Dim close
		close = 1 / (horizontal / 100)
		close = close / 10
		close = close * close + 1

		Select Case angle
			// 当水平距离越近时，垂直距离越远，力度越大
			// 当水平距离越远时，垂直距离越远，力度增大的幅度变小
			Case 20
				strength = strength + upOffset(0) * vertical * close
			Case 30
				strength = strength + upOffset(1) * vertical * close
			Case 35
				strength = strength + upOffset(2) * vertical * close
			Case 40
				strength = strength + upOffset(3) * vertical * close
			Case 45
				strength = strength + upOffset(4) * vertical * close
			Case 50
				If close >= 5 Then 
					close = close * 2
				ElseIf close >= 3.5 Then 
					close = close * 1.2
				End If
				strength = strength + upOffset(5) * vertical * close
			Case 65
				If close >= 10 Then 
					close = close * 2
				End If
				strength = strength + upOffset(6) * vertical / 1.5 * close
			Case 70
				If close >= 30 Then 
					close = close * 1.3
				End If
				strength = strength + upOffset(7) * vertical * close
		End Select
	End If
	getStrength = strength
	// 44 - 55
End Function

/**
 * 带角度的攻击
 * angle: 角度
 * strength: 力度
 * mis: 角度误差
 **/
Sub attackWithAngle(angle, strength, mis)
	Dim failCount, lastAngle
	failCount = 0
	nowAngle = getAngle()
	lastAngle = nowAngle
	While nowAngle < angle - mis Or nowAngle > angle + mis
		If nowAngle = lastAngle Then 
			failCount = failCount + 1
		Else 
			failCount = 0
		End If
		If failCount > 8 Then 
			// 超过3次尝试变更角度不动，说明需要移动
			// TODO 复杂情况（走到了边缘后走不动）的处理
			Select Case getToward()
				Case 0
					dm.keyPressChar "a"
					dm.keyPressChar "a"
					dm.keyPressChar "a"
					Delay 10
				Case 1
					dm.keyPressChar "d"
					dm.keyPressChar "d"
					dm.keyPressChar "d"
					Delay 10
			End Select
		End If
		If getAngle() < (angle + mis)
			dm.keyPressChar "w"
			Delay 5
		End If
		If getAngle() > (angle - mis)
			dm.keyPressChar "s"
			Delay 5
		End If
		lastAngle = nowAngle
		nowAngle = getAngle()
	Wend
	// 力度无误
	Call attack(strength)
End Sub

// 获取当前朝向：0为左，1为右，-1表示未知
// TODO 检测度提升的方法：获取角度值，若角度超过90则说明当前角度是反的，目前不考虑倒抛
Function getToward()
	If dm.findColor(0, 500, 50, 600, "FF0000-401010|f0f000-404010", 1.0, 0, intX, intY) Then 
		getToward = 0
	ElseIf dm.findColor(50, 500, 100, 600, "FF0000-401010|f0f000-404010", 1.0, 0, intX, intY) Then 
		getToward = 1
	Else 
		getToward = - 1 
		TracePrint "朝向获取失败"
	End If
End Function

// 指定力度攻击
Sub attack(strength)
	Dim str, tried, startX, endX, checkY, strength1
	// startX、endX：力度条的起始和终止位置
	startX = 151
	endX = 646
	// 1力度的像素偏移值
	strength1 = (endX - startX + 1) / 100
	// checkY：检测力度条颜色变化的y轴
	checkY = 591
	tried = 0
	str = LCase(LTrim(Form1.InputBox2.Text + ""))
	While len(str) > 0
		dm.keyPressChar Left(str, 1)
		str = Right(str, Len(str) - 1)
	Wend
	// 计算力度
	If strength > 95 Then 
		strength = 95
	End If
	// 出手前检测是否能够出手，防止卡死
	If isMyRound() Then 
		dm.keyDown 32
		If Form1.CheckBox4.Value Then 
			// 攻击方式2，当目标点颜色变动时松手
			Delay 100
			Dim lastColor
			lastColor = dm.getColorBGR(startX + strength1 * strength - 1, checkY)
			While true
				c = dm.getColorBGR(startX + strength1 * strength - 1, checkY)
				If lastColor <> c Then 
					// 找到了
					dm.keyUp 32
					While isMyRound()
						Delay 200
					Wend
					Exit Sub
				Else 
					lastColor = c
				End If
				Delay 1
			Wend
		Else 
			dm.keyDown 32
			Dim c
			While true
				c = dm.getColor(startX + strength1 * strength - 1, checkY)
				If c = "ce351b" OR c = "ab622a" Then 
					dm.keyUp 32
					While isMyRound()
						Delay 200
					Wend
					Exit Sub
				End If
				Delay 1
				tried = tried + 1
				If tried > 20000 Then 
					dm.keyUp 32
					exit Sub
				End If
			Wend
		End If
		dm.keyUp 32
	End If
End Sub

Sub needCloseMap
	// 先点击进入选副本页面
	dm.FindPic 510, 430, 710, 530, "C:\tmp\蛋4.5-随机地图.bmp", 101010, 0.8, 0, intX, intY
	If intX > 0 And intY > 0 Then 
		dm.moveTo intX + 10, intY + 10
		dm.leftClick 
		Delay 300
		dm.FindPic 495, 70, 523, 98, "C:\tmp\蛋4.5-大副本页标识.bmp", 101010, 0.8, 0, intX, intY
		If intX > 0 And intY > 0 Then 
			TracePrint "第" & (n + 1) & "次" & "副本，开始"
			Call 要打的副本
		End If
	End If
	dm.FindPic 495, 70, 523, 98, "C:\tmp\蛋4.5-大副本页标识.bmp", 101010, 0.8, 0, intX, intY
	If intX > 0 And intY > 0 Then 
			TracePrint "第" & (n + 1) & "次" & "副本，开始"
			Call 要打的副本
	End If
	dm.FindPic 920, 440, 980, 510, "C:\tmp\蛋4.5-开始1.bmp", 101010, 0.9, 0, intX, intY
	If intX > 0 And intY > 0 Then 
		dm.moveTo intX + 10, intY + 10
		dm.leftClick 
	End If

	dm.FindPic 920, 440, 980, 510, "C:\tmp\蛋4.5-开始2.bmp", 101010, 0.9, 0, intX, intY
	If intX > 0 And intY > 0 Then 
		dm.moveTo intX, intY
		dm.leftClick 
	End If
End Sub

Sub needCloseTip
	dm.FindPic 610, 230, 670, 270, "C:\tmp\蛋4.5-单人模式提示.bmp", 101010, 0.8, 0, intX, intY
	If intX > 0 And intY > 0 Then 
		dm.moveTo 412, 339
		dm.leftClick
	End If
End Sub

Sub needCloseEmail
	dm.FindPic 550, 120, 770, 280, "C:\tmp\蛋4.5-邮件.bmp", 101010, 0.8, 0, intX, intY
	If intX > 0 And intY > 0 Then 
		dm.moveTo 830, 50
		dm.leftClick
	End If
End Sub

// 检测是否需要准备
Sub needPrepare
	dm.FindPic 920, 430, 980, 500, "C:\tmp\蛋4.5-准备1.bmp", 101010, 0.9, 0, intX, intY
	If intX > 0 And intY > 0 Then 
		// 购买怒气
		dm.moveTo 878,337
		dm.leftClick 
		dm.leftClick 
		dm.leftClick 
		// 点击准备
		dm.moveTo intX, intY
		dm.leftClick 
		Delay 3000
	End If
End Sub

Function isEnterLevel()
	dm.FindPic 960, 0, 999, 23, "C:\tmp\蛋4.5-本内退出.bmp", 303030, 0.8, 0, px, py
	If px > 0 and py > 0 Then 
		isEnterLevel = true
	Else 
		isEnterLevel = False
	End If
End Function

Function isMyRound()
	isMyRound = False
	If dm.FindPic(960, 180, 990, 210, "C:\tmp\蛋4.5-出手判定1.bmp", 101010, 0.8, 0, intX, intY) = - 1  and dm.FindPic(960, 180, 990, 210, "C:\tmp\蛋4.5-出手判定2.bmp", 101010, 0.8, 0, intX, intY) = - 1  Then 
		isMyRound = False
	ElseIf dm.FindPic(476, 158, 525, 176, "C:\tmp\蛋4.5-该出手了.bmp", 303030, 0.4, 0, intX, intY) > - 1  Then
		isMyRound = True
	End If
End Function

Sub needDraw
	Dim isEnd
	isEnd = False
	dm.FindPic 88, 59, 904, 571, "C:\tmp\蛋4.5-卡牌.bmp", 101010, 0.8, 0, px, py
	While px > 0 and py > 0
		Form1.Label4.Caption = "第" & (n + 1) & "次抽卡，祝好运 0v0~"
		For 3
			While px > 0 and py > 0
				dm.moveTo px, py
				dm.leftClick 
				dm.FindPic 88, 59, 904, 571, "C:\tmp\蛋4.5-卡牌.bmp", 101010, 0.8, 0, px, py
				If Form1.CheckBox3.Value Then 
					If dm.FindPic(650, 200, 780, 300, "C:\tmp\蛋4.5-翻第三张牌.bmp", 101010, 0.8, 0, px2, py2) Then 
						dm.moveTo 382, 340
						dm.leftClick 
						Delay 1000
					End If
				End If
				Delay 500 * Rnd()
			Wend
			Delay 1000
		Next
		dm.FindPic 88, 59, 904, 571, "C:\tmp\蛋4.5-卡牌.bmp", 101010, 0.8, 0, px, py
	Wend
	If isEnd Then 
		n = n + 1
		Form1.Label4.Caption = "第" & n & "次副本，结束！"
	End If
End Sub


/**
 * --------------------------备用函数区-------------------------------
 **/
// 获取角色位置，由于三角出现在角色上方3个像素~5个像素的位置，传进来小地图角色位置最上方中间像素（3个中的中间）
Function getPlace(x1, y1, x2, y2, x3, y3, x4, y4)
	getPlace = -1
	If x1 > 0 And y1 > 0 Then 
		If roleInArea(x1 - 2, y1 - 7, x1 + 2, y1 - 2) Then 
			getPlace = 1
			Exit Function
		End If
	End if
	If x2 > 0 And y2 > 0 Then 
		If roleInArea(x2 - 2, y2 - 7, x2 + 2, y2 - 2) Then 
			getPlace = 2
			Exit Function
		End If
	End If
	If x3 > 0 And y3 > 0 Then 
		If roleInArea(x3 - 1, y3 - 6, x3 + 1, y3 - 3) Then 
			getPlace = 3
			Exit Function
		End If
	End If
		
	If x4 > 0 And y4 > 0 Then 
		If roleInArea(x4 - 1, y4 - 6, x4 + 1, y4 - 3) Then 
			getPlace = 4
			Exit Function
		End If
	End If
End Function
Function roleInArea(x1, y1, x2, y2)
	roleInArea = dm.findColor (x1, y1, x2, y2, roleColor + "-101010", 1.0, 0, intX, intY)
End Function



/**
 * ---------------------------文件区-------------------------------
 */

// 保存所有打手的句柄，在运行挂机脚本时排除这些句柄
Sub saveMaster(hwnd)
	If debug Then 
		TracePrint hwnd
	End If
	
	Dim hwndFile
	hwndFile = "C:/tmp/hwnds.txt"
	If Plugin.File.IsFileExist(hwndFile) = False Then 
		Plugin.File.WriteFileEx hwndFile, hwnd
	ElseIf Len(Lib.文件.读取指定行文本内容(hwndFile, 0)) = 0 Then
		// 文件存在但内容为空
		Call Lib.文件.替换指定行文本内容(hwndFile, hwnd, 0)
	Else 
		// 读取原内容，并将,句柄加在后面
		arr = strToArray(Lib.文件.读取指定行文本内容(hwndFile, 0))
		If UBOUND(arr) = - 1  Then 
			Call Lib.文件.替换指定行文本内容(hwndFile, hwnd, 0)
		Else 
			Dim repeat, resultStr
			repeat = false
			
			For i = 0 To UBOUND(arr)
				// 句柄存在
				If Plugin.Window.IsWindow(arr(i)) = 1 Then 
					resultStr = resultStr & arr(i) & ","
				End If
				If (arr(i) + 0) = hwnd Then 
					repeat = true
				End If
			Next
			If repeat = false Then 
				resultStr = resultStr & hwnd & ","
			End If
			If Len(resultStr) <> 0 Then 
				resultStr = Left(resultStr, Len(resultStr) - 1)
			End If
			If debug Then 
				TracePrint resultStr
			End If
			Call Lib.文件.替换指定行文本内容(hwndFile,resultStr,0)
		End If
	End If
End Sub

Function strToArray(str)
	strToArray = Split(str, ",")
End Function

/**
 * --------------------------固定函数区-------------------------------
 */
Sub hwndCheck(hwnd)
    // 窗口已经过期，结束线程即可
	If Plugin.Window.IsWindow(hwnd) = 0  Then 
		MsgBox "检测到窗口关闭，即将结束本次运行"
		ExitScript
	End If
End Sub

/**
 * ---------------------------大漠区-------------------------------
**/

Sub 大漠注册
	need_ver = "3.1233"
	// 防止被系统精简掉导致的中注册失败
	Set ws=createobject("Wscript.Shell")
	ws.run "regsvr32 atl.dll /s"
	Set ws = nothing
	// 释放插件
	PutAttachment "c:\tmp", "*.*"
	PutAttachment ".\Plugin", "RegDll.dll"
	// 使用RegDll注册
	Call Plugin.RegDll.Reg("c:\tmp\dm.dll")
	set dm = createobject("dm.dmsoft")
	ver = dm.Ver()
	if ver <> need_ver then
		// 先释放先前创建的dm
		set dm = nothing
		// 再尝试用regsvr32 来注册. 这里必须使用绝对路径。以免有别人把dm.dll释放在系统目录.造成版本错误.
		set ws=createobject("Wscript.Shell")
		ws.run "regsvr32 c:\tmp\dm.dll /s"
		set ws=nothing
		Delay 1500  
		// 再判断插件是否注册成功
		set dm = createobject("dm.dmsoft")
		ver = dm.Ver()
		if ver <> need_ver then
			// 这时，已经确认插件注册失败了。 弹出一些调试信息，以供分析.
			messagebox "插件版本错误,当前使用的版本是:"&ver&",插件所在目录是:"&dm.GetBasePath()
			messagebox "请关闭程序,重新打开本程序再尝试"
    		endscript
  		End If
	Else 
  		TracePrint "注册成功"
	End If
	dm.SetPath "c:\tmp"
End Sub

Sub bund(hwnd)
	Set dm = createobject("dm.dmsoft")
	dm_ret = dm.BindWindowEx(hwnd, "dx2", "dx2", "dx", "dx.public.active.message", 4)
	if dm_ret = 0 then
   		last_error = dm.GetLastError()
		// 如果是WIN7 VISTA WIN2008系统,检测当前系统是否有开启UAC
   		if dm.GetOsType() = 3 then
    		// 有开启UAC的话，尝试关闭
				if dm.CheckUAC() = 1 then
     				if dm.SetUAC(0) = 1 then
          				// 关闭UAC之后，必须重启系统才可以生效
          				messagebox "已经关闭系统UAC设置，必须重启系统才可以生效。点击确定重启系统"
         				// dm.ExitOs 2
                		Delay 2000
         				endscript
     				end if
				end if
   		end if
   		// 具体错误码的含义，可以参考函数GetLastError的说明.
   		MessageBox "绑定失败，错误码是:" & last_error
   		EndScript
		Else 
   		TracePrint "绑定成功"
	End If
	// 选择字库文件
	dm_ret = dm.SetDict(0, "C:/tmp/ddtankLibrary4.5.txt")
	// 使用字库文件的编号
	dm_ret = dm.UseDict(0)
End Sub

Sub OnScriptExit()
   dm.UnBindWindow
End Sub

