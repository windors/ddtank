Dim hwnd
Dim round
Dim position
Dim toward
Dim n
Dim checkTimes
Dim antFirst
Call init
Sub init
	checkTimes = 0
	n = 0
	If (Form1.InputBox1.Text + 0) <> - 1  Then 
		MessageBox "选择了手动指定句柄"
		hwnd = Form1.InputBox1.Text
	Else 
		hwnd = Plugin.Window.MousePoint
	End If
	If (Plugin.Window.GetClass(hwnd) <> "MacromediaFlashPlayerActiveX") Then 
		MessageBox "未检测到窗口，请重新运行脚本，启动时鼠标需要放在游戏内！"
	Else 
		Call main
	End If
End Sub

Sub main
	Call 大漠注册
	Call bund(hwnd)
	// 将主句柄保存
	Call saveMaster(hwnd)
	dm.moveTo 0, 0
	dm.leftClick 
	While True
		checkTimes = checkTimes + 1
		If checkTimes > 100 Then 
			checkTimes = 0
		End If
		// 检测hwnd是否失效
		Call hwndCheck(hwnd)
		
		// 检测是否需要选地图
		Call needPrepare
		Call needChoseMap
		Call needCloseTip
		Call needCloseEmail
		// 检测是否需要出手
		Call needAttack
		// 检测是否需要将奖励放进背包
		If checkTimes Mod 5 = 0 Then 
			Call needCreateRoom
			Call needDraw
		End If
		Delay 700 * (1 - (Form1.Slider1.Value / 1000))
	Wend
End Sub


Sub needCreateRoom
	dm.FindPic 670, 470, 735, 530, "C:\tmp\大厅标识.bmp", 101010, 0.8, 0, intX, intY
	If intX > 0 And intY > 0 Then 
	 	TracePrint "检测到在大厅内"
		dm.moveTo intX + 10, intY + 10
		dm.leftClick 
		
		Delay 500
		dm.moveTo 411, 442
		dm.leftClick 
		Delay 1000
	End If
End Sub

Sub 打副本策略
	round = round + 1
	Form1.Label4.Caption = "第" & (n + 1) & "次副本，第" & round & "回合"
	While isMyRound()
		Call attackAuto
	Wend
	
	/*
	Select Case (Form1.ComboBox1.ListIndex * 4 + Form1.ComboBox2.ListIndex)
		Case 0
			Call attackWithAngle(20, 50, 1)
		Case 1
			Call attackWithAngle(20, 45, 1)
		Case 2
			Call attackWithAngle(25, 40, 1)
		Case 3
			Call attackWithAngle(20, 45, 1)
		Case 4
			Call attackWithAngle(20, 45, 1)
		Case 5
			Call attackWithAngle(20, 45, 1)
		Case 6
			Call attackWithAngle(20, 45, 1)
		Case 7
			Call attackWithAngle(20, 45, 1)
		Case 8
			Call attackWithAngle(30, 38, 1)	
		Case 9
			Call attackWithAngle(20, 46, 1)
		Case 10
			Call attackWithAngle(30, 38, 1)	
		Case 11
			Call attackWithAngle(20, 45, 1)
		Case 12
			Call attackWithAngle(20, 45, 1)
		Case 13
			// 斜坡未验证
			Call attackWithAngle(20, 45, 1)
		Case 14
			Call attackWithAngle(20, 45, 1)
		Case 15
			Call attackWithAngle(20, 45, 1)
		Case 16
			Call attackWithAngle(20, 45, 1)
		Case 17
			Call attackWithAngle(20, 45, 1)
		Case 18
			Call attackWithAngle(20, 45, 1)
		Case 19
			Call attackWithAngle(20, 45, 1)
		Case 20
			Call attackWithAngle(20, 45, 1)
		Case 21
			Call attackWithAngle(20, 45, 1)
		Case 22
			Call attackWithAngle(20, 45, 1)
		Case 23
			Call attackWithAngle(30, 38, 1)
		Case 24
			Call attackWithAngle(30, 38, 1)
		Case 25
			Call attackWithAngle(20, 45, 1)
		Case 26
			Call attackWithAngle(20, 45, 1)
		Case 27
			alert ("懒得写这个本")
		Case 28
			Call attackWithAngle(20, 45, 1)
		Case 29
			Call attackWithAngle(20, 45, 1)
		Case 30
			Call attackWithAngle(20, 45, 1)
		Case 31
			Call attackWithAngle(20, 45, 1)
		Case 32
			Call attackWithAngle(20, 45, 1)
		Case 33
			Call attackWithAngle(20, 45, 1)
		Case 34
			Call attackWithAngle(20, 45, 1)
		Case 35
	End Select
	*/
End Sub

// ok
Sub 要打的副本
	Dim x, y
	// x, y 待选择副本的位置
	round = 0
	position = 0
	toward = 0
	Form1.Label4.Caption = "第" & (n + 1) & "次副本，开始！"
	
	Select Case Form1.ComboBox1.ListIndex Mod 3
		// 选择行
		Case 0
			y = 324
		Case 1
			y = 375
		Case 2
			y = 428
	End Select
	If Form1.ComboBox1.ListIndex > 3 Then 
		For Fix(Form1.ComboBox1.ListIndex / 3)
			dm.moveTo 805, 430
			dm.leftClick 
			dm.moveTo 805, 431
			dm.leftClick 
			dm.leftClick
		Next
	End If
	
	Select Case Form1.ComboBox2.ListIndex Mod 4
		Case 0
			x = 329
		Case 1
			x = 461
		Case 2
			x = 604
		Case 3
			x = 738
	End Select
	
	
	dm.moveTo x, y
	dm.leftClick 
	// 难度，全简单
	dm.moveTo 370,501
	dm.leftClick
	dm.moveTo 735, 568
	dm.leftClick 
	Delay 300
End Sub

// 获取角色位置，由于三角出现在角色上方3个像素~5个像素的位置，传进来小地图角色位置最上方中间像素（3个中的中间）
Function getPlace(x1, y1, x2, y2, x3, y3, x4, y4)
	getPlace = -1
	If x1 > 0 And y1 > 0 Then 
		If roleInArea(x1 - 2, y1 - 7, x1 + 2, y1 - 2) Then 
			getPlace = 1
			Exit Function
		End If
	End if
	If x2 > 0 And y2 > 0 Then 
		If roleInArea(x2 - 2, y2 - 7, x2 + 2, y2 - 2) Then 
			getPlace = 2
			Exit Function
		End If
	End If
	If x3 > 0 And y3 > 0 Then 
		If roleInArea(x3 - 1, y3 - 6, x3 + 1, y3 - 3) Then 
			getPlace = 3
			Exit Function
		End If
	End If
		
	If x4 > 0 And y4 > 0 Then 
		If roleInArea(x4 - 1, y4 - 6, x4 + 1, y4 - 3) Then 
			getPlace = 4
			Exit Function
		End If
	End If
End Function

Function roleInArea(x1, y1, x2, y2)
	roleInArea = dm.findColor (x1, y1, x2, y2, "00CCFF-101010", 1.0, 0, intX, intY)
End Function

/**
 * 带角度的攻击
 * angle: 角度
 * strength: 力度
 * mis: 误差
 **/
Sub attackWithAngle(angle, strength, mis)
	Dim failCount, lastAngle
	failCount = 0
	lastAngle = -2100000000
	nowAngle = getAngle()
	While nowAngle < angle - mis Or nowAngle > angle + mis
		If nowAngle = lastAngle Then 
			failCount = failCount + 1
		Else 
			failCount = 0
		End If
		If failCount > 3 Then 
			// 超过3次尝试变更角度不动，说明需要移动
			If dm.findColor(59, 497, 108, 590, "FF0000-200000", 1.0, 0, intX, intY) Then 
				// 朝向右
				// TODO 复杂情况（走到了边缘后走不动）的处理
				dm.keyPressChar "d"
				dm.keyPressChar "d"
				dm.keyPressChar "d"
				dm.keyPressChar "d"
				dm.keyPressChar "d"
				TracePrint "需要按d"
			ElseIf dm.findColor(20, 500, 55, 590, "FF0000-200000", 1.0, 0, intX, intY) Then 
				dm.keyPressChar "a"
				dm.keyPressChar "a"
				dm.keyPressChar "a"
				dm.keyPressChar "a"
				dm.keyPressChar "a"
				TracePrint "需要按a"
			Else 
				
			End If
		End If
		If getAngle() < (angle + mis)
			dm.keyPressChar "w"
			Delay 88
		End If
		If getAngle() > (angle - mis)
			dm.keyPressChar "s"
			Delay 88
		End If
		lastAngle = nowAngle
		nowAngle = getAngle()
	Wend
	// 力度无误
	Call attack(strength)
End Sub

/**
 * 自动寻找屏距，兵计算攻击
 **/
Sub attackAuto
	// 寻找符合颜色要求的，第一行连续超过n个，第二行少于n但大于0的图像位置，并且下方1-5个px的周围包含超过连续10个符合要求像素个数的位置
	If dm.findStr(843, 20, 999, 114, "我", "00ccff-a01030", 0.8, x1, y1) = 0 Then 
		// 找敌人坐标
		If dm.findColor(843, 20, 999, 114, "ff0000-000000", 1, 0, x2, y2) Then 
			Dim strength
			TracePrint Fix((x2 - x1)/(Form1.InputBox3.Text) + 0.0001) + 1
			Select Case Fix((x2 - x1)/(Form1.InputBox3.Text) + 0.0001) + 1
				Case 1
					strength = 14
				Case 2
					strength = 20
				Case 3
					strength = 24
				Case 4
					strength = 28
				Case 5
					strength = 32
				Case 6
					strength = 35
				Case 7
					strength = 38
				Case 8
					strength = 41
				Case 9
					strength = 44
				Case 10
					strength = 47
				Case 11
					strength = 50
				Case 12
					strength = 52
				Case 13
					strength = 55
				Case 14
					strength = 57
				Case 15
					strength = 60
				Case 16
					strength = 62
				Case 17
					strength = 65
				Case 18
					strength = 67
				Case 19
					strength = 69
				Case 20
					strength = 72
			End Select
			strength = strength + 3
			Call attackWithAngle(30, strength, 1)
		End If
	Else 
		Delay 1
	End If
End Sub

/**
 * 在某个像素点周围寻找颜色相似的像素个数
 **/
Function countContinuousColor(x1, y1, c)
	Dim x, y, flag, nextX, nextY, alreadyX, alreadyY
	x = x1
	y = y1
	flag = false
	countContinuousColor = 0
	// Step1：找到最左面（优先级高）、最上面的点
	While flag = false
		While dm.CmpColor(x - 1, y, c)
			x = x - 1
			flag = true
		Wend
		While dm.CmpColor(x, y - 1, c)
			y = y - 1
			flag = false
		Wend
	Wend
	// Step2：统计每一列，同时当右面的像素符合要求时，向上爬取，直到最顶层
	While dm.CmpColor(x, y, c)
		countContinuousColor = countContinuousColor + 1
		If dm.CpmColor(x + 1, y) Then 
			nextX = x + 1
			nextY = y
			// 右面的点可行，寻找右面列符合要求的最上面的一个点
			While dm.CmpColor(nextX, nextY - 1, c)
				nextY = nextY - 1
			Wend
			alreadyX = nextX
			alreadyY = nextY
			If nextX <> alreadyX And nextY <> alreadyY Then 
				// 说明找到了下一个列（防止出现统计类似“K”字型时仅统计上半部分的情况
				While dm.CmpColor(alreadyX, alreadyY)
					countContinuousColor = countContinuousColor + 1
					alreadyY = alreadyY + 1
				Wend
			End If
		End If
		// 当前向下爬取
		y = y + 1
	Wend
	// 全部统计完毕后若alreadyX, alreadyY 都大于0，说明最后一个列未处理
	If alreadyX > 0 And alreadyY > 0 Then 
		While dm.CmpColor(alreadyX, alreadyY)
			countContinuousColor = countContinuousColor + 1
			alreadyY = alreadyY + 1
		Wend
	End If
End Function

Function getAngle()
	// BGR：1a1a1a 0d261a 241710 16201a 2b2228 0d0d26 201d1c 321d17 1d1d21 030d1c
	getAngle = dm.Ocr(40, 550, 85, 590, "1a1a1a-000000|1a260d-000000|101724-000000|1a2016-000000|28222b-000000|260d0d-000000|1c1d20-000000|211d1d-000000|171d32-000000|1c0d03-000000", 1) + 0
End Function

Sub attack(strength)
	Dim str, tried
	tried = 0
	str = LCase(LTrim(Form1.InputBox2.Text + ""))
	While len(str) > 0
		dm.keyPressChar Left(str, 1)
		str = Right(str, Len(str) - 1)
	Wend
	// 计算力度
	If strength > 95 Then 
		strength = 95
	End If
	// 出手前检测是否能够出手，防止卡死
	If isMyRound() Then 
		dm.keyDown 32
		While dm.getColor(156 + Fix(4.99 * strength) - 2, 596) <> "6d2802"
			tried = tried + 1
			Delay 1
			If tried > 20000 Then 
				dm.keyUp 32
				exit Sub
			End If
		Wend
		dm.keyUp 32
	End If
End Sub

Sub needChoseMap
	// 先点击，然后再检测
	dm.FindPic 511, 437, 685, 527, "C:\tmp\随机地图.bmp", 101010, 0.8, 0, intX, intY
	If intX > 0 And intY > 0 Then 
		dm.moveTo intX + 10, intY + 10
		dm.leftClick 
		Delay 300
		dm.FindPic 261, 71, 349, 122, "C:\tmp\选副本页面.bmp", 101010, 0.8, 0, intX, intY
		If intX > 0 And intY > 0 Then 
			TracePrint "第" & (n + 1) & "次" & "副本，开始"
			Call 要打的副本
		End If
	End If
	dm.FindPic 261, 71, 349, 122, "C:\tmp\选副本页面.bmp", 101010, 0.8, 0, intX, intY
		If intX > 0 And intY > 0 Then 
			TracePrint "第" & (n + 1) & "次" & "副本，开始"
			Call 要打的副本
		End If
	dm.FindPic 910, 450, 970, 500, "C:\tmp\开始1.bmp", 101010, 0.9, 0, intX, intY
	If intX > 0 And intY > 0 Then 
		dm.moveTo intX + 10, intY + 10
		dm.leftClick 
	End If

	dm.FindPic 910, 450, 970, 510, "C:\tmp\开始2.bmp", 101010, 0.9, 0, intX, intY
	If intX > 0 And intY > 0 Then 
		dm.moveTo intX, intY
		dm.leftClick 
	End If
End Sub

Sub needCloseTip
	dm.FindPic 650, 228, 691, 258, "C:\tmp\单人模式提示.bmp", 101010, 0.8, 0, intX, intY
	If intX > 0 And intY > 0 Then 
		dm.moveTo 432, 345
		dm.leftClick
	End If
End Sub

Sub needCloseEmail
	dm.FindPic 125, 86, 344, 113, "C:\tmp\邮件.bmp", 101010, 0.8, 0, intX, intY
	If intX > 0 And intY > 0 Then 
		dm.moveTo 836, 52
		dm.leftClick
	End If
End Sub

// 检测是否需要准备
Sub needPrepare
	dm.FindPic 900, 440, 970, 520, "C:\tmp\准备.bmp", 101010, 0.9, 0, intX, intY
	If intX > 0 And intY > 0 Then 
		// 购买怒气
		dm.moveTo 878,337
		dm.leftClick 
		dm.leftClick 
		dm.leftClick 
		// 点击准备
		dm.moveTo intX, intY
		dm.leftClick 
		Delay 3000
	End If
End Sub

Sub needAttack
	If isMyRound() Then 
		Call 打副本策略
	End If
End Sub

Function isMyRound()
	isMyRound = False
	dm.FindPic 123, 114, 198, 135, "C:\tmp\该出手了.bmp", 101010, 0.8, 0, intX, intY
	If intX > 0 And intY > 0 Then 
		isMyRound = True
	End If
End Function

Sub needDraw
	dm.FindPic 88, 59, 904, 571, "C:\tmp\翻牌卡.bmp", 101010, 0.8, 0, px, py
	While px > 0 and py > 0
		Form1.Label4.Caption = "第" & (n + 1) & "次抽卡，祝好运 0v0~"
		For 3
			While px > 0 and py > 0
				dm.moveTo px, py
				dm.leftClick 
				dm.FindPic 88, 59, 904, 571, "C:\tmp\翻牌卡.bmp", 101010, 0.8, 0, px, py
				dm.moveTo 438, 342
				dm.leftClick 
				Delay 1000 * Rnd()
			Wend
			Delay 1000
		Next
		dm.FindPic 88, 59, 904, 571, "C:\tmp\翻牌卡.bmp", 101010, 0.8, 0, px, py
	Wend
	Call needPutInBag
End Sub

// 蛋2独有的副本结束后需要将物品放入背包 ok
Sub needPutInBag
	Dim isEnd
	isEnd = False
	dm.FindPic 385, 218, 407, 246, "C:\tmp\全选进背包.bmp", 101010, 0.8, 0, px, py
	While px > 0 and py > 0
		TracePrint "检测到结束窗口"
		isEnd = True
		// 普通模式
		dm.moveTo px, py
		dm.leftClick 
		Delay 5000
		dm.FindPic 385, 218, 407, 246, "C:\tmp\全选进背包.bmp", 101010, 0.8, 0, px, py
	Wend
	If isEnd Then 
		n = n + 1
		Form1.Label4.Caption = "第" & n & "次副本，结束！"
	End If
End Sub

Sub hwndCheck(hwnd)
    // 窗口已经过期，结束线程即可
	If Plugin.Window.IsWindow(hwnd) = 0  Then 
		MsgBox "检测到窗口关闭，即将结束本次运行"
		ExitScript
	End If
End Sub

// 保存所有打手的句柄，在运行挂机脚本时排除这些句柄
Sub saveMaster(hwnd)
	TracePrint hwnd
	Dim hwndFile
	hwndFile = "C:/tmp/hwnds.txt"
	If Plugin.File.IsFileExist(hwndFile) = False Then 
		Plugin.File.WriteFileEx hwndFile, hwnd
	ElseIf Len(Lib.文件.读取指定行文本内容(hwndFile, 0)) = 0 Then
		// 文件存在但内容为空
		Call Lib.文件.替换指定行文本内容(hwndFile, hwnd, 0)
	Else 
		// 读取原内容，并将,句柄加在后面
		arr = strToArray(Lib.文件.读取指定行文本内容(hwndFile, 0))
		If UBOUND(arr) = - 1  Then 
			Call Lib.文件.替换指定行文本内容(hwndFile, hwnd, 0)
		Else 
			Dim repeat, resultStr
			repeat = false
			
			For i = 0 To UBOUND(arr)
				// 句柄存在
				If Plugin.Window.IsWindow(arr(i)) = 1 Then 
					resultStr = resultStr & arr(i) & ","
				End If
				If (arr(i) + 0) = hwnd Then 
					repeat = true
				End If
			Next
			If repeat = false Then 
				resultStr = resultStr & hwnd & ","
			End If
			If Len(resultStr) <> 0 Then 
				resultStr = Left(resultStr, Len(resultStr) - 1)
			End If
			TracePrint resultStr
			Call Lib.文件.替换指定行文本内容(hwndFile,resultStr,0)
		End If
	End If
End Sub

Function strToArray(str)
	strToArray = Split(str, ",")
End Function

/**
 * ---------------------------大漠区-------------------------------
**/

Sub 大漠注册
	need_ver = "3.1233"
	// 防止被系统精简掉导致的中注册失败
	Set ws=createobject("Wscript.Shell")
	ws.run "regsvr32 atl.dll /s"
	Set ws = nothing
	// 释放插件
	PutAttachment "c:\tmp", "*.*"
	PutAttachment ".\Plugin", "RegDll.dll"
	// 使用RegDll注册
	Call Plugin.RegDll.Reg("c:\tmp\dm.dll")
	set dm = createobject("dm.dmsoft")
	ver = dm.Ver()
	if ver <> need_ver then
		// 先释放先前创建的dm
		set dm = nothing
		// 再尝试用regsvr32 来注册. 这里必须使用绝对路径。以免有别人把dm.dll释放在系统目录.造成版本错误.
		set ws=createobject("Wscript.Shell")
		ws.run "regsvr32 c:\tmp\dm.dll /s"
		set ws=nothing
		Delay 1500  
		// 再判断插件是否注册成功
		set dm = createobject("dm.dmsoft")
		ver = dm.Ver()
		if ver <> need_ver then
			// 这时，已经确认插件注册失败了。 弹出一些调试信息，以供分析.
			messagebox "插件版本错误,当前使用的版本是:"&ver&",插件所在目录是:"&dm.GetBasePath()
			messagebox "请关闭程序,重新打开本程序再尝试"
    		endscript
  		End If
	Else 
  		TracePrint "注册成功"
	End If
	dm.SetPath "c:\tmp"
End Sub

Sub bund(hwnd)
	Set dm = createobject("dm.dmsoft")
	dm_ret = dm.BindWindowEx(hwnd, "dx2", "dx2", "dx", "dx.public.active.message", 4)
	if dm_ret = 0 then
   		last_error = dm.GetLastError()
		// 如果是WIN7 VISTA WIN2008系统,检测当前系统是否有开启UAC
   		if dm.GetOsType() = 3 then
    		// 有开启UAC的话，尝试关闭
				if dm.CheckUAC() = 1 then
     				if dm.SetUAC(0) = 1 then
          				// 关闭UAC之后，必须重启系统才可以生效
          				messagebox "已经关闭系统UAC设置，必须重启系统才可以生效。点击确定重启系统"
         				// dm.ExitOs 2
                		Delay 2000
         				endscript
     				end if
				end if
   		end if
   		// 具体错误码的含义，可以参考函数GetLastError的说明.
   		MessageBox "绑定失败，错误码是:" & last_error
   		EndScript
		Else 
   		TracePrint "绑定成功"
	End If
	// 选择字库文件
	dm_ret = dm.SetDict(0, "C:/tmp/ddtankLibrary.txt")
	// 使用字库文件的编号
	dm_ret = dm.UseDict(0)
End Sub

Sub OnScriptExit()
   dm.UnBindWindow
End Sub
