Dim hwnd, keyHwnd
Dim round
Dim toward
Dim n
Dim checkTimes
Dim debug
// 小地图角色的颜色
Dim roleColor
// 小地图的左上和右下点
Dim static_x1, static_x2, static_x3, static_x4
// 我的坐标&敌人的坐标
Dim positionX1, positionX2, positionY1, positionY2
// 偏移量
Dim dx, dy, mode
Dim isCaledUnitDistance

Call init

Sub init
	static_x1 = 794
	static_y1 = 23
	static_x2 = 1000
	static_y2 = 122
	debug = true
	// 角色小地图颜色
	// roleColor = "00ccff"
	roleColor = "0033cc"
	// 计数器初始化
	checkTimes = 0	// 初始化已打副本次数
	n = 0
	dx = 0
	dy = 0
	mode = "1"
	hwnd = Plugin.Window.MousePoint
	keyHwnd = hwnd
	Dim className, success
	success = false
	className = Plugin.Window.GetClass(hwnd)

	If (className = "MacromediaFlashPlayerActiveX") Then 
		success = true
	ElseIf className = "Internet Explorer_Server" Then
		// QQ浏览器
		success = true
		If Lib.ddt.offsetRepair(hwnd) Then 
			success = true
			Call Plugin.Msg.Tips("警告：QQ浏览器（前台模式，切勿调整大小及缩小）")
		End If
	Else 
		// 勾选了极速模式
		If Form1.CheckBox5.Value Then 
			mode = "2"
			Dim title
			title = Plugin.Window.GetText(hwnd)
			If className = "Chrome_RenderWidgetHostHWND" and title = "Chrome Legacy Window" Then 
				// 360极速
				hwnd = Plugin.Window.GetParentWindow(hwnd)
				If Plugin.Window.GetParentWindow(hwnd) = 0 Then 
					If Lib.ddt.offsetRepair(hwnd) Then 
						success = true
						Call Plugin.Msg.Tips ("警告：360极速浏览器（前台模式，切勿调整窗口大小及缩小，关闭弹窗后尽量不要移动窗口位置，多开需要注意将窗口分离出来）")
					End If
				Else
					// 确认是否是QQ浏览器，这俩最下边的句柄类名和标题都一样
					If Plugin.Window.GetClass(hwnd) = "Chrome_WidgetWin_1" Then 
						hwnd = Plugin.Window.GetParentWindow(hwnd)
						If Plugin.Window.GetClass(hwnd) = "QQBrowser_WidgetWin_1" Then 
							If Plugin.Window.GetParentWindow(hwnd) = 0 Then 
								// TODO QQ浏览器
								If Lib.ddt.offsetRepair(hwnd) Then 
									success = true
									Call Plugin.Msg.Tips("警告：QQ极速浏览器（前台模式，切勿调整窗口大小及缩小，关闭弹窗后尽量不要移动窗口位置，多开需要注意将窗口分离出来）")
								End If
							End If
						End If
					ElseIf Plugin.Window.GetClass(hwnd) = "Chrome_WidgetWin_0" Then 
						// 确认是否是Flash自带游览器
						hwnd = Plugin.Window.GetParentWindow(hwnd)
						If Plugin.Window.GetClass(hwnd) = "CefBrowserWindow" Then 
							hwnd = Plugin.Window.GetParentWindow(hwnd)
							If Plugin.Window.GetClass(hwnd) = "Qt5152QWindowIcon" Then 
								hwnd = Plugin.Window.GetParentWindow(hwnd)
								If Plugin.Window.GetClass(hwnd) = "Qt5152QWindowIcon" Then 
									hwnd = Plugin.Window.GetParentWindow(hwnd)
									If Plugin.Window.GetClass(hwnd) = "Qt5152QWindowIcon" Then 
										If Plugin.Window.GetParentWindow(hwnd) = 0 Then 
											success = true
											If Lib.ddt.offsetRepair(hwnd) Then 
												success = true
												Call Plugin.Msg.Tips ("警告：Flash自带浏览器（前台模式，切勿调整窗口大小及缩小，关闭弹窗后尽量不要移动窗口位置，多开需要注意将窗口分离出来）")
											End If
										End If
									End If
								End If
							End If
						End If
					End If
				End If
			End If
		End If
	End If
	If success Then 
		Form1.Label4.Caption = "脚本启动成功，句柄：" & hwnd
		Form1.debug1.Text = hwnd : Form1.debug2.Text = keyHwnd : Form1.debug3.Text = dx : Form1.debug4.Text = dy : Form1.debug5.Text = mode
		Call Lib.ddt.大漠注册
		Call Lib.ddt.bund(hwnd, mode)
		// 选择字库文件，改1
		dm_ret = dm.SetDict(0, "C:/tmp/ddtankLibrary10.4.txt")
		// 字库文件的编号
		dm_ret = dm.UseDict(0)
		// 将主句柄保存
		Call Lib.ddt.saveMaster(hwnd)
		TracePrint "偏移量：" & dx & ", " & dy
		
		dm.FindPic 0, 0, 1000, 600, "C:\tmp\矫正标识.bmp", 303030, 0.8, 0, intX, intY
		TracePrint "后台模式标准值：" & intX & ", " & intY
		
		Call main
	Else 
		MessageBox "未检测到游戏窗口，请将游戏放至游戏窗口内启动"
	End If
End Sub

Sub main
	While True
		While Form1.debug0.Text
			checkTimes = checkTimes + 1
			If checkTimes > 100 Then 
				checkTimes = 0
			End If
			If checkTimes Mod 5 = 1 Then 
				Call needActiveWindow
			End If
			// 检测hwnd是否失效
			Call hwndCheck(hwnd)
			If isEnterLevel() Then 
				If Form1.CheckBox7.Value Then 
					If isCaledUnitDistance = false Then 
						isCaledUnitDistance = true
						Call calcUnitDistance
					End If
				End If
				While isMyRound() and isEnterLevel()
					Call 打副本策略
				Wend
			Else 
				// 检测是否需要选地图
				Call needPrepare
				Call needChooseMap
				Call needCloseTip
				Call needCloseEmail
				// 检测是否需要将奖励放进背包
				If checkTimes Mod 5 = 0 Then 
					Call needGoingToWharf
					Call needCreateRoom
					Call needDraw
				End If
			End If
			Delay 700 * (1 - (Form1.Slider1.Value / 1000))
		Wend
	Wend
End Sub

Function isEnterLevel()
	dm.FindPic 960 + dx, 0 + dy, 999 + dx, 32 + dy, "C:\tmp\蛋10.4-本内退出.bmp", 303030, 0.7, 0, px, py
	If px > 0 and py > 0 Then 
		isEnterLevel = true
	Else 
		dm.FindPic 960 + dx, 0 + dy, 999 + dx, 32 + dy, "C:\tmp\蛋10.4-本内退出2.bmp", 303030, 0.7, 0, px, py
		If px > 0 and py > 0 Then 
			isEnterLevel = true
		Else 
			isEnterLevel = False
		End If
	End If
End Function

// 改2
Function needActiveWindow
	If dm.FindPic(450 + dx, 250 + dy, 530 + dx, 330 + dy, "C:\tmp\蛋10.4-需要激活窗口.bmp", 303030, 0.8, 0, intX, intY) > - 1  Then 
		offsetMoveTo 870, 130
		dm.leftClick
	End If
End Function


Sub needCreateRoom
	dm.FindPic 560 + dx, 490 + dy, 700 + dx, 550 + dy, "C:\tmp\蛋10.4-大厅标识.bmp", 101010, 1, 0, intX, intY
	If intX > 0 And intY > 0 Then 
	 	TracePrint "需要创建房间"
		dm.moveTo intX , intY
		dm.leftClick 
		Delay 1000
	End If
End Sub


Sub needGoingToWharf
	dm.FindPic 500 + dx, 90 + dy, 1000 + dx, 180 + dy, "C:\tmp\蛋10.4-大厅.bmp", 101010, 1, 0, intX, intY
	If intX > 0 And intY > 0 Then 
	 	TracePrint "检测到在大厅内，即将去远征码头"
		dm.moveTo intX , intY
		dm.leftClick 
		Delay 3000
	End If
End Sub

Sub 打副本策略
	round = round + 1
	Form1.Label4.Caption = "第" & (n + 1) & "次副本，第" & round & "回合"
	TracePrint "第" & round & "回合"
	If Form1.controlInput1.Text Then 
		Select Case round Mod 6
			Case 0
				Call roundAttackLogicCore(Form1.InputBox9.Text)
			Case 1
				Call roundAttackLogicCore(Form1.InputBox9.Text)
			Case 2
				Call roundAttackLogicCore(Form1.InputBox9.Text)
			Case 3
				Call roundAttackLogicCore(Form1.InputBox9.Text)
			Case 4
				Call roundAttackLogicCore(Form1.InputBox9.Text)
			Case 5
				Call roundAttackLogicCore(Form1.InputBox9.Text)
		End Select
	Else 
		Call roundAttackLogicCore(Form1.InputBox2.Text)
	End If
	
	
	
End Sub

Sub roundAttackLogicCore(str)
	str = LCase(str + "")
	If InStr(str, "p") > 0 Then 
		// 技能带p，直接按技能即可
		While len(str) > 0
			Lib.键盘.myKeyPressChar hwnd, keyHwnd, Left(str, 1)
			str = Right(str, Len(str) - 1)
		Wend
	Else 
		If isCaledUnitDistance = False Then 
		 	TracePrint "计算屏距"
			Call calcUnitDistance()
			isCaledUnitDistance = True
		End If
		While isMyRound()
			Call attackAuto(str)
		Wend
	End If
End Sub

// 改4
Sub 要打的副本
	Call initEveryTimes
	Dim x, y
	// x, y 待选择副本的位置
	Form1.Label4.Caption = "第" & (n + 1) & "次副本，开始！"
	
	// 副本模式
	offsetMoveTo 221 + 525 * (Form1.Slider3.Value / 100), 190
	dm.leftClick 
	Delay 800
	
	Select Case Form1.ComboBox1.ListIndex Mod 2
		// 选择行
		Case 0
			y = 230
		Case 1
			y = 290
	End Select
	
	// 对于需要翻页的副本将那些的操作，该端的翻页逻辑是点两下滑块，再点一下按钮
	If Form1.ComboBox1.ListIndex > 1 Then 
		
		For Fix(Form1.ComboBox1.ListIndex / 2)
			For 2
				offsetMoveTo 775, 300
				dm.leftDown 
				dm.leftUp
				Delay 100
				dm.leftDown 
				dm.leftUp
				Delay 100
				offsetMoveTo 775, 310
				dm.leftDown 
				dm.leftUp
				Delay 100
			Next
		Next
	End If
	
	Select Case Form1.ComboBox2.ListIndex Mod 4
		Case 0
			x = 280
		Case 1
			x = 420
		Case 2
			x = 560
		Case 3
			x = 700
	End Select
	offsetMoveTo x, y
	dm.leftClick 
	Delay 100
	// 难度，根据输入框输入调整
	offsetMoveTo 224 + 554 * (Form1.Slider2.Value / 100), 500
	dm.leftClick 
	
	// 点击确定
	offsetMoveTo 480, 560
	dm.leftClick 
	Delay 300
End Sub

/**
 * 自动寻找屏距，并计算攻击
 **/
Sub attackAuto(str)
	If Form1.CheckBox1.Value Then 
		// 指定角度力度攻击
		Call attackWithAngle(Form1.InputBox4.Text, Form1.InputBox5.Text, Form1.InputBox7.Text, str)
	Else 
		// 寻找自身位置
		If getMyPosition() and getEnemyPosition() Then 
			TracePrint "我的坐标:" & positionX1 & ", " & positionY1
			TracePrint "敌人的坐标:" & positionX2 & ", " & positionY2
			Call adjustDirection()
			
			// 自动攻击
			Call calcAndAttack(str)
		Else 
			// 未找到自身位置
			Delay 1
		End If
	End If
End Sub

// 尝试计算屏距
Function calcUnitDistance()
	// 自动寻找屏距，循环10次
	Dim count, flag, arr(10)
	For i = 0 To 10
		arr(i) = -1
		flag = true
		For 5
			If dm.findStr(static_x1 + dx, static_y1 + dy, static_x2 + dx, static_y2 + dy, "屏", "999999-000000", 1, x3, y3) = 0 Then 
				If flag Then 
					count =1
				End If
				While flag
					If dm.findColor(x3, y3, static_x2 + dx, y3 + 1, "999999-000000", 1, 0, x4, y4) Then 
						count = count + 1
						x3 = x3 + 1
					Else
						flag = false
					End If
					If x3 >= static_x2 Then 
						flag = false
					End If
				Wend
				Exit For
			End If
		Next
		If debug Then 
			TracePrint "第" & i & "次测量屏距：" & count & "px"
		End If
		arr(i) = count
	Next
	
	// 先排序
	For i = 0 To UBound(arr)
		For j = 0 To UBound(arr) - 1 - i
			If arr(i) > arr(j) Then 
				Dim tmp
				tmp = arr(i)
				arr(i) = arr(j)
				arr(j) = tmp
			End If
		Next
	Next
	
	Dim maxTimes, times, nowDistance, maxDistance
	For i = 0 To UBound(arr)
		If arr(i) <> nowDistance Then 
			times = 1
			nowDistance = arr(i)
		Else 
			times = times + 1
		End If
		If times > maxTimes Then 
			maxTimes = times
			maxDistance = nowDistance
		End If
	Next
	
	// 投票选择出最佳屏距
	If debug Then 
		TracePrint "1屏的距离为" & maxDistance & "px" & "出现次数" & times
	End If
	// count / 10为1距，更新距离
	Form1.InputBox3.Text = maxDistance / 10
	dm_ret = dm.UseDict(0)
End Function

// 调整方向
Sub adjustDirection
	toward = -1
	While isMyRound() and toward = - 1 
		toward = getToward()
		If toward = 1 and positionX2 - positionX1 < 0 Then 
			// 朝向右，但敌人在左
			Lib.键盘.myKeyPressChar hwnd, keyHwnd,  "a"
			TracePrint "调整方向(左)"
		End If
		If toward = 0 and positionX2 - positionX1 > 0 Then 
			// 朝向左，但敌人在右
			Lib.键盘.myKeyPressChar hwnd, keyHwnd,  "d"
			TracePrint "调整方向(右)"
		End If
	Wend
End Sub

// 计算角度力度并攻击 x1, y1 : 我的坐标，y1, y2: 敌人的坐标
Sub calcAndAttack(str)
	Dim strength, angle
	If Form1.CheckBox1.Value Then 
		// 手动攻击
		angle = Form1.InputBox4.Text
		strength = Form1.InputBox5.Text
	End If

	If Form1.CheckBox6.Value Then 
		Select Case Form1.ComboBox4.ListIndex
			Case 0
				angle = 20
			Case 1
				angle = 30
			Case 2
				angle = 35
			Case 3
				angle = 40
			Case 4
				angle = 45
			Case 5
				angle = 50
			Case 6
				angle = 65
			Case 7
				angle = 70
		End Select
	ElseIf Form1.CheckBox8.Value Then
		angle = getClosestAngle()
	Else 
		angle = Lib.ddt.getBestAngle(positionY2 - positionY1, Abs(positionX2 - positionX1), Form1.InputBox3.Text)
	End If
	
	strength = Lib.ddt.getStrength(angle, Abs((positionX2 - positionX1) / Form1.InputBox3.Text), ((positionY1 - positionY2) / Form1.InputBox3.Text))
	strength = strength + Form1.InputBox6.Text
	
	TracePrint "角度" & angle & "力度:" & strength
	Call attackWithAngle(angle, strength, Form1.InputBox7.Text, str)
End Sub

Function getClosestAngle()
	Dim nowAngle
	nowAngle = getAngle()
	If nowAngle <= 20 Then 
		getClosestAngle = 20
	ElseIf nowAngle <= 30 Then 
		getClosestAngle = 30
	ElseIf nowAngle <= 40 Then
		getClosestAngle = 40
	ElseIf nowAngle <= 45 Then
		getClosestAngle = 45
	ElseIf nowAngle <= 50 Then
		getClosestAngle = 50
	ElseIf nowAngle <= 65 Then
		getClosestAngle = 65
	Else 
		getClosestAngle = 70
	End If
End Function

// 寻找我的坐标
Function getMyPosition()
	If dm.findStr(static_x1 + dx, static_y1 + dy, static_x2 + dx, static_y2 + dy, "我", roleColor + "-000000", 0.8, intX, intY) = 0 Then 
		positionX1 = intX
		positionY1 = intY
		// 大漠找字默认找的是最上方坐标
		positionY1 = positionY1 + 10
		getMyPosition = True
	Else 
		getMyPosition = False
	End If
End Function

// 寻找敌人的坐标
Function getEnemyPosition()
	If dm.findColor(static_x1 + dx, static_y1 + dy, static_x2 + dx, static_y2 + dy, "ff0000-000000", 1, Form1.ComboBox3.ListIndex, intX, intY) Then 
		positionX2 = intX - 2
		positionY2 = intY + 1
		getEnemyPosition = True
	ElseIf dm.findColor(static_x1 + dx, static_y1 + dy, static_x2 + dx, static_y2 + dy, "99cc00-000000", 1, Form1.ComboBox3.ListIndex, intX, intY) Then
		// 找绿色（小鸡本（淦））
		positionX2 = intX - 2
		positionY2 = intY + 1
		
		getEnemyPosition = True
		TracePrint intX & ", " & intY
	Else 	
		TracePrint "未找到敌人"
		Delay 1
		getEnemyPosition = False
	End If
End Function

// 获取当前角度
Function getAngle()
	// BGR：1a1a1a 0d261a 241710 16201a 2b2228 0d0d26 201d1c 321d17 1d1d21 030d1c
	getAngle = dm.Ocr(23 + dx, 552 + dy, 77 + dx, 590 + dy, "000-000", 0.95)
	getAngle = Replace(getAngle, "我", "")
	getAngle = Replace(getAngle, "屏", "")
	getAngle = getAngle + 0
End Function



/**
 * 带角度的攻击
 * angle: 角度
 * strength: 力度
 * mis: 角度误差
 **/
Sub attackWithAngle(angle, strength, mis, str)
	Dim failCount, lastAngle
	failCount = 0
	angle = angle + Form1.InputBox1.Text
	nowAngle = getAngle()
	lastAngle = nowAngle
	While (nowAngle < angle - mis Or nowAngle > angle + mis) and isEnterLevel()
		If nowAngle = lastAngle Then
			failCount = failCount + 1
		Else 
			failCount = 0
		End If
		If failCount > 3 Then 
			// 超过3次尝试变更角度不动，说明需要移动
			// TODO 复杂情况（走到了边缘后走不动）的处理
			Select Case getToward()
				Case 0
					Lib.键盘.myKeyPressChar hwnd, keyHwnd,  "a"
					Lib.键盘.myKeyPressChar hwnd, keyHwnd,  "a"
					Lib.键盘.myKeyPressChar hwnd, keyHwnd,  "a"
					Delay 10
				Case 1
					Lib.键盘.myKeyPressChar hwnd, keyHwnd,  "d"
					Lib.键盘.myKeyPressChar hwnd, keyHwnd,  "d"
					Lib.键盘.myKeyPressChar hwnd, keyHwnd,  "d"
					Delay 10
			End Select
		End If
		If nowAngle < (angle + mis) Then 
			For angle + mis - nowAngle
				Lib.键盘.myKeyDownChar hwnd, keyHwnd, "w"
				Lib.键盘.myKeyUpChar hwnd, keyHwnd, "w"
			Next
			Delay 80
		End If
		If nowAngle > (angle - mis)
			For nowAngle - angle + mis
				Lib.键盘.myKeyDownChar hwnd, keyHwnd, "s"
				Lib.键盘.myKeyUpChar hwnd, keyHwnd,  "s"
			Next
			Delay 80
		End If
		lastAngle = nowAngle
		nowAngle = getAngle()
	Wend
	// 力度无误
	Call attack(strength, str)
End Sub

// 获取当前朝向：0为左，1为右，-1表示未知
// TODO 检测度提升的方法：获取角度值，若角度超过90则说明当前角度是反的，目前不考虑倒抛
Function getToward()
	Dim left, right
	angle = Abs(getAngle())
	If angle <= 70 Then 
		right = dm.GetResultCount(dm.findColorEx(60 + dx, 500 + dy, 100 + dx, 600 + dy, "B27F2C-101010|F0C040-101010|B00000-300000|F00000-101010", 1.0, 0))
		left = dm.GetResultCount(dm.findColorEx(0 + dx, 500 + dy, 40 + dx, 600 + dy, "B27F2C-101010|F0C040-101010|B00000-300000|F00000-101010", 1.0, 0))
		If right > left Then 
			getToward = 1
		Elseif right < left Then
			getToward = 0
		Else 
			getToward = -1
		End If
	Else 
		right = dm.GetResultCount(dm.findColorEx(50 + dx, 500 + dy, 100 + dx, 600 + dy, "B27F2C-101010|F0C040-101010|B00000-300000|F00000-101010", 1.0, 0))
		left = dm.GetResultCount(dm.findColorEx(0 + dx, 500 + dy, 50 + dx, 600 + dy, "B27F2C-101010|F0C040-101010|B00000-300000|F00000-101010", 1.0, 0))
		If right > left Then 
			If angle <= 90 Then 
				getToward = 1
			Else 
				getToward = 0
			End If
		Elseif right < left Then
			If angle <= 90 Then 
				getToward = 0
			Else 
				getToward = 1
			End If
		Else 
			getToward = -1
		End If
	End If
	If debug Then 
		If getToward = 0 Then 
			TracePrint "当前方向：左"
		ElseIf getToward = 1 Then
			TracePrint "当前方向：右"
		Else 
			TracePrint "当前方向：未知方向"
		End If
	End If
End Function

// 指定力度攻击
Sub attack(strength, str)
	Dim tried, startX, endX, checkY, strength1
	// startX、endX：力度条的起始和终止位置
	startX = 151 + dx
	endX = 646 + dx
	// 1力度的像素偏移值
	strength1 = (endX - startX + 1) / 100
	// checkY：检测力度条颜色变化的y轴
	checkY = 591 + dy
	tried = 0
	While len(str) > 0
		Lib.键盘.myKeyDownChar hwnd, keyHwnd, Left(str, 1)
		Lib.键盘.myKeyUpChar hwnd, keyHwnd, Left(str, 1)
		str = Right(str, Len(str) - 1)
	Wend
	// 计算力度
	If strength > 95 Then 
		strength = 95
	End If
	// 出手前检测是否能够出手，防止卡死
	If isMyRound() Then 
		Lib.键盘.myKeyDownChar hwnd, keyHwnd, " "
		If Form1.CheckBox4.Value Then 
			// 攻击方式2，当目标点颜色变动时松手
			Delay 100
			Dim lastColor
			lastColor = dm.getColorBGR(startX + strength1 * strength - 1, checkY)
			While true
				c = dm.getColorBGR(startX + strength1 * strength - 1, checkY)
				If lastColor <> c Then 
					// 找到了
					Lib.键盘.myKeyUpChar hwnd, keyHwnd, " "
					While isMyRound()
						Delay 200
					Wend
					Exit Sub
				Else 
					lastColor = c
				End If
				Delay 1
			Wend
		Else 
			Lib.键盘.myKeyDownChar hwnd, keyHwnd, " "
			Dim c
			While true
				c = dm.getColor(startX + strength1 * strength - 1, checkY)
				If c = "a76433" OR c = "d63a1a" Then 
					Lib.键盘.myKeyUpChar hwnd, keyHwnd, " "
					While isMyRound()
						Delay 200
					Wend
					Exit Sub
				End If
				tried = tried + 1
				If tried Mod 100 = 0 Then
					If isMyRound() = False Then 
						Exit Sub
					End If
				End If
				If tried > 20000 Then 
					Lib.键盘.myKeyUpChar hwnd, keyHwnd, " "
					exit Sub
				End If
			Wend
		End If
		Lib.键盘.myKeyUpChar hwnd, keyHwnd, " "
	End If
End Sub

Sub initEveryTimes
	isCaledUnitDistance = false
	round = 0
End Sub

Sub needChooseMap
	// 先点击进入选副本页面
	dm.FindPic 500 + dx, 400 + dy, 740 + dx, 500 + dy, "C:\tmp\蛋10.4-随机地图.bmp", 101010, 0.8, 0, intX, intY
	If intX > 0 And intY > 0 Then 
		dm.moveTo intX + 10, intY + 10
		dm.leftClick 
		Delay 300
		dm.FindPic 200 + dx, 30 + dy, 320 + dx, 80 + dy, "C:\tmp\蛋10.4-大副本页标识.bmp", 101010, 0.8, 0, intX, intY
		If intX > 0 And intY > 0 Then 
			TracePrint "第" & (n + 1) & "次" & "副本，开始"
			Call 要打的副本
			
		End If
	End If
	dm.FindPic 200 + dx, 30 + dy, 320 + dx, 80 + dy, "C:\tmp\蛋10.4-大副本页标识.bmp", 101010, 0.8, 0, intX, intY
	If intX > 0 And intY > 0 Then 
			TracePrint "第" & (n + 1) & "次" & "副本，开始"
			Call 要打的副本
	End If
	dm.FindPic 900 + dx, 430 + dy, 990 + dx, 550 + dy, "C:\tmp\蛋10.4-开始1.bmp", 101010, 0.9, 0, intX, intY
	If intX > 0 And intY > 0 Then 
		Call initEveryTimes
		TracePrint "第" & (n + 1) & "次" & "副本，开始"
		dm.moveTo intX + 10, intY + 10
		dm.leftClick 
	End If
End Sub

Sub needCloseTip
	dm.FindPic 610 + dx, 210 + dy, 790 + dx, 270 + dy, "C:\tmp\蛋10.4-单人模式提示.bmp", 101010, 0.8, 0, intX, intY
	If intX > 0 And intY > 0 Then 
		offsetMoveTo 376, 319
		dm.leftClick
		offsetMoveTo 405, 352
		dm.leftClick
	End If
	
	dm.FindPic 900 + dx, 330 + dy, 980 + dx, 400 + dy, "C:\tmp\蛋10.4-tip.bmp", 101010, 0.8, 0, intX, intY
	If intX > 0 And intY > 0 Then 
		offsetMoveTo intX + 20, intY + 10
		dm.leftClick
	End If
End Sub

Sub needCloseEmail
	dm.FindPic 570 + dx, 190 + dy, 760 + dx, 280 + dy, "C:\tmp\蛋10.4-邮件.bmp", 101010, 0.8, 0, intX, intY
	If intX > 0 And intY > 0 Then 
		offsetMoveTo 850, 60
		dm.leftClick 
	End If
End Sub

// 检测是否需要准备
Sub needPrepare
	dm.FindPic 900 + dx, 430 + dy, 990 + dx, 550 + dy, "C:\tmp\蛋10.4-准备.bmp", 101010, 0.9, 0, intX, intY
	If intX > 0 And intY > 0 Then 
		// 购买怒气
		offsetMoveTo 878,337
		dm.leftClick 
		dm.leftClick 
		dm.leftClick 
		// 点击准备
		dm.moveTo intX, intY
		dm.leftClick 
		Delay 3000
	End If
End Sub

Function isMyRound()
	isMyRound = False
	find1 = dm.FindPic(955 + dx, 160 + dy, 990 + dx, 200 + dy, "C:\tmp\蛋10.4-出手判定1.bmp", 000000, 0.7, 0, intX, intY)
	find2 = dm.FindPic(955 + dx, 160 + dy, 990 + dx, 200 + dy, "C:\tmp\蛋10.4-出手判定2.bmp", 000000, 0.7, 0, intX2, intY2)
	If find1 = - 1  and find2 = - 1  Then 
		isMyRound = False
	Else 
		If dm.FindPic(476 + dx, 158 + dy, 525 + dx, 176 + dy, "C:\tmp\蛋10.4-该出手了.bmp", 202020, 0.5, 0, intX, intY) > - 1  Then
			isMyRound = True
		Else 
			If dm.FindPic(476 + dx, 158 + dy, 525 + dx, 176 + dy, "C:\tmp\蛋10.4-该出手了2.bmp", 202020, 0.5, 0, intX, intY) > - 1  Then 
				isMyRound = True
			Else 
				If dm.FindPic(476 + dx, 158 + dy, 525 + dx, 176 + dy, "C:\tmp\蛋10.4-该出手了3.bmp", 202020, 0.5, 0, intX, intY) > - 1  Then 
					isMyRound = True
				Else
				End If
			End If
		End If
	End If
End Function

Sub needDraw
	Dim isEnd
	isEnd = False
	dm.FindPic 88 + dx, 59 + dy, 904 + dx, 571 + dy, "C:\tmp\蛋10.4-卡牌.bmp", 101010, 0.8, 0, px, py
	While px > 0 and py > 0
		isEnd = true
		Form1.Label4.Caption = "第" & (n + 1) & "次抽卡，祝好运 0v0~"
		For 3
			While px > 0 and py > 0
				dm.moveTo px, py
				dm.leftClick 
				
				If dm.FindPic(650 + dx, 200 + dy, 750 + dx, 280 + dy, "C:\tmp\蛋10.4-翻第三张牌.bmp", 101010, 0.8, 0, px2, py2) > -1 Then 
					TracePrint px2
					If Form1.CheckBox3.Value Then 
						offsetMoveTo 400, 340
						dm.leftClick 
						dm.leftClick 
						Delay 1000
					Else 
						Delay 3000
					End If
				End If
				Delay 100 * Rnd()
				dm.FindPic 88 + dx, 59 + dy, 904 + dx, 571 + dy, "C:\tmp\蛋10.4-卡牌.bmp", 101010, 0.8, 0, px, py
			Wend
			// Delay 1000
		Next
		dm.FindPic 88 + dx, 59 + dy, 904 + dx, 571 + dy, "C:\tmp\蛋10.4-卡牌.bmp", 101010, 0.8, 0, px, py
	Wend
	If isEnd Then 
		n = n + 1
		Form1.Label4.Caption = "第" & n & "次副本，结束！"
		Delay 1000* (Form1.InputBox8.Text + 0)
	End If
End Sub


/**
 * --------------------------偏移支持区-------------------------------
 */

Sub offsetMoveTo(x, y)
	dm.moveTo x + dx, y + dy
End Sub

/**
 * --------------------------固定函数区-------------------------------
 */
Sub hwndCheck(hwnd)
    // 窗口已经过期，结束线程即可
	If Plugin.Window.IsWindow(hwnd) = 0  Then 
		MsgBox "检测到窗口关闭，即将结束本次运行"
		ExitScript
	End If
End Sub

/**
 * ---------------------------大漠区-------------------------------
**/

Sub OnScriptExit()
   dm.UnBindWindow
End Sub


Event Form1.Button1.Click
	Form1.Container2.Top = - 2
End Event

Event Form1.Button2.Click
	Form1.Container2.Top = 300
End Event


// 点击了自定义回合
Event Form1.Button5.Click
	MessageBox "本版本不添加自定义回合攻击"
	// Form4.Top = 0
End Event
Event Form1.Button4.Click
	Form1.controlInput1.Text = 1
	MessageBox "本次脚本将按自定义的回合来进行攻击"
End Event

// 副本模式
Event Form1.Slider3.Slide
	hwnd = Form1.debug1.Text
	// offsetMoveTo 221 + 525 * (Form1.Slider3.Value / 10), 190
	If Plugin.Window.IsWindow(hwnd) Then 
		Call showPointWindow
		places = Plugin.Window.GetClientRect(hwnd)
		places = Split(places, "|")
		Plugin.Window.Move Form4.Hwnd, places(0) + dx + 221 + 525 * (Form1.Slider3.Value / 100) - Form4.Width / 2, places(1) + dy + 190 - Form4.Height - 32
	End If
End Event
// 难度矫正
Event Form1.Slider2.Slide
	hwnd = Form1.debug1.Text
	// offsetMoveTo 224 + 554 * (Form1.Slider2.Value / 100), 500
	If Plugin.Window.IsWindow(hwnd) Then 
		Call showPointWindow
		places = Plugin.Window.GetClientRect(hwnd)
		places = Split(places, "|")
		Plugin.Window.Move Form4.Hwnd, places(0) + dx + 224 + 554 * (Form1.Slider2.Value / 100) - Form4.Width / 2, places(1) + dy + 500 - Form4.Height - 32
	End If
End Event
Sub showPointWindow
	If Form1.showInput1.Text Then 
	Else 
		Form4.Show 
		Plugin.Window.Top Form4.hwnd, 0
	End If
End Sub
Event Form4.LoadOver
	Form1.showInput1.Text = 1
End Event
Event Form4.UnLoad
	Form1.showInput1.Text = 0
End Event